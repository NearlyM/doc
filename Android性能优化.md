# Android性能优化

android系统开源，所以存在各种各样的系统定制。于是开发者会针对不同的系统做各种适配，譬如：后台长连接的维持。这个问题会导致android电量消耗过快。当然国家针对这一块也在做努力，统一推送联盟。

android的性能优化主要从下面几个点展开吧。

1. 内存优化
2. 绘制优化
3. 网络优化
4. 电量优化
5. 稳定性优化
6. apk大小优化

## 一、内存优化

app的内存优化主要是从面几点来。

1. 内存分析

   当虚拟机频繁的垃圾回收时，会导致卡顿，因为此刻会对内存现状进行快照。

   当分配对象地址的时候，可能会发生oom，导致应用崩溃。

   如果应用内存占用高的话，会影响应用后台存活率

   

   减少oom，可以提高应用稳定性

   减少卡顿，提升应用流畅性

   优化应用内存使用，提高应用后台存活率

   分析应用内存，可以使用android studio自带工具 profiler



2. 内存泄露

   由于java对象不需要手动去释放，这样的便捷性吸引了一大堆开发者。当然对于C/C++开发者来说，可能会不习惯。

   但是正是由于这样的方便设计，导致如果出现了内存泄露，就比较难定位。当然我们可以通过内存分析工具，Profiler中的Memory去定位。

   但是在开发过程中，我们也应该去避免内存泄露。主要注意一下几点：

   1. 非静态内部类

      非静态内部类默认持有外部内的引用，如果内部类正在被占用，当外部类不在使用的时候，是不能被释放的。举个例子：Handler，android中的Handler如果以上面这种方式被使用，Handler持有了Activity的引用，而Handler被消息Message持有，消息在等待被处理。这个时候销毁Activity，该Activity是不能被回收的。

      这种情况下可以这样去处理。

      1. 静态内部类
      2. 非静态内部类弱引用外部类

   2. 资源型对象未关闭

      File文件，数据库操作是使用Cursor，但是使用完了没有调用close。如果我们没有关闭它，系统在回收时也会关掉它，但是效率太低。

   3. 注册的对象没有注销。

      注册了一些广播，没有及时的去注销

   4. 非静态内部类的静态实例

   5. 类的静态变量持有大数据

   可以使用leakCanary去监测。

减少不必要的内存开销，比如自动装箱。内存复用。使用最优的数据类型

## 二、绘制优化

应用启动慢，卡顿。是很多用户使用时候的问题。

应用启动的时候，会先去Lancher的onPause，同时去新建进程，开启新的应用。这调用Lancher的onPause之后，系统在服务端进程会调用一个方法showStartWindow，这个方法就是系统为了应用的连贯性，先给开发者来展示应用的界面，避免点击长时间空白。这个window展示的是应用中的lancher中的window。

界面绘制引起的卡顿有一下几点：

界面层级太深，导致绘制耗时，可以尽量减少界面深度。比如使用<merge>，可以复用父布局的约束。减少一层。

或者使用relative布局，使用起来更灵活。避免设置不必要的背景。

当然在某些界面可以实现懒加载，<ViewStub>

在自定义空间中，我们要避免不必要的全局绘制，可以部分区域刷新的，尽量刷新部分区域。



界面绘制卡顿原理：

因为目前基本上所有手机的屏幕刷新频率是60hz，大概是16ms一帧，所以当绘制时间超过16ms，就会出现卡顿现象。

google也在不断的优化这个问题，例如双缓冲技术，三缓冲技术。

真正将要显示的数据刷新的屏幕上，是通过系统级进程SurfaceFlinger来实现的。

在android的显示系统，使用了android匿名共享内存：SharedClient。

每一个应用和SurfaceFlinger之间都会创建一个SharedClient。在每个ShareClient中，最多可以创建31个SurfaceBufferStack，每个SurfaceBufferStack对应一个surface，也就是一个window，SurfaceBufferStack中包含两个或者三个缓冲区。

## 三、稳定性优化

代码审查

crash监控以及上报机制

anr避免

## 四、电量优化

使用wifi是的功率要低于移动网络

使用移动网络的时候有三种耗电状态：

高功率 低功率 空闲态

1. 尽量使用WiFi传输数据
2. 移动网络下，尽量避免频繁的网络请求。

优化：

1. 尽量使用高效运算
2. 避免wakelock使用不当